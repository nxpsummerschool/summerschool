---
title: "Lab 4 exercises"
date:  June 25, 2024
output: pdf_document
---

1. Implement the Caesar cipher using a TLV encoding on UART. Have separate commands for encryption and decryption. Shift by 3 characters.
2. Use source files from aes to change encryption algorithm from exercise 1.
   The AES algorithm works on blocks of 16 bytes (input/output):
    *  Data must be sliced into 16 byte chunks.
    *  The file logo.txt contains raw data of nxp logo in hex.
    *  We have to copy encrypted data and save it as .bmp file.
3. Encrypt the NXP logo, save encrypted data as image and check it.
4. Implement CBC mode of operation.
    * CBC mode of operation use diffusion to break patterns in encrypted data.
    * each encrypted data block is XORed with next plain data block before encryption.
    * For first block an IV (initialization vector) is used.

   Encrypt the message below.
   'See you at 13 o'clock in class, do not be late!!!'
   Modify input data for decryption algorithm in such way the decrypted text still appears valid.
   !Hint if you change one byte from IV only corresponding byte from first block will be altered.
6. Implement CCM mode of operation.


	* Use test vectors from below to confirm implemenation and then encrypt fallowing mesage,
    *  o CCM mode of operation will generate an authentication tag along with encrypted text.
    * Tag must be verified during decription process.

    Test vectors:
    1
	    Key will be hardcoded in the program with:
        `uint8_t key[]={0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08};`
	    For an input of 10 bytes: `{F0}{F0}{00}{00}{00}{00}{00}{00}{08}{08}`
        We should receive: `{F1}{F2}{03}{04}{05}{06}{07}{08}{F8}{F8}{00}{00}{00}{00}{00}{00}`
	2 AES 256 ECB

        `uint8_t key [] =  {0x60, 0x3d, 0xeb, 0x10, 0x15, 0xca, 0x71, 0xbe,
                            0x2b, 0x73, 0xae, 0xf0, 0x85, 0x7d, 0x77, 0x81,
                            0x1f, 0x35, 0x2c, 0x07, 0x3b, 0x61, 0x08, 0xd7,
                            0x2d, 0x98, 0x10, 0xa3, 0x09, 0x14, 0xdf, 0xf4 }`
        `uint8_t plain [] = {0x6b, 0xc1, 0xbe, 0xe2, 0x2e, 0x40, 0x9f, 0x96,
                             0xe9, 0x3d, 0x7e, 0x11, 0x73, 0x93, 0x17, 0x2a}`
		`uint8_t cipher [] = {0xf3, 0xee, 0xd1, 0xbd, 0xb5, 0xd2, 0xa0, 0x3c,
		                      0x06, 0x4b, 0x5a, 0x7e, 0x3d, 0xb1, 0x81, 0xf8}`
	3 AES 256 CBC
	    `uint8_t key [] =  {0x60, 0x3d, 0xeb, 0x10, 0x15, 0xca, 0x71, 0xbe,
                            0x2b, 0x73, 0xae, 0xf0, 0x85, 0x7d, 0x77, 0x81,
                            0x1f, 0x35, 0x2c, 0x07, 0x3b, 0x61, 0x08, 0xd7,
                            0x2d, 0x98, 0x10, 0xa3, 0x09, 0x14, 0xdf, 0xf4}`
        `uint8_t iv [] =    {0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
                             0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f}`
        `uint8_t plain [] = {0x6b, 0xc1, 0xbe, 0xe2, 0x2e, 0x40, 0x9f, 0x96,
                             0xe9, 0x3d, 0x7e, 0x11, 0x73, 0x93, 0x17, 0x2a,
							 0xae, 0x2d, 0x8a, 0x57, 0x1e, 0x03, 0xac, 0x9c,
							 0x9e, 0xb7, 0x6f, 0xac, 0x45, 0xaf, 0x8e, 0x51,
							 0x30, 0xc8, 0x1c, 0x46, 0xa3, 0x5c, 0xe4, 0x11,
							 0xe5, 0xfb, 0xc1, 0x19, 0x1a, 0x0a, 0x52, 0xef,
							 0xf6, 0x9f, 0x24, 0x45, 0xdf, 0x4f, 0x9b, 0x17,
							 0xad, 0x2b, 0x41, 0x7b, 0xe6, 0x6c, 0x37, 0x10}`
        `uint8_t cipher [] = {0xF5, 0x8C, 0x4C, 0x04, 0xD6, 0xE5, 0xF1, 0xBA,
                              0x77, 0x9E, 0xAB, 0xFB, 0x5F, 0x7B, 0xFB, 0xD6,
                              0x9C, 0xFC, 0x4E, 0x96, 0x7E, 0xDB, 0x80, 0x8D
                              0x67, 0x9F, 0x77, 0x7B, 0xC6, 0x70, 0x2C, 0x7D,
                              0x39, 0xF2, 0x33, 0x69, 0xA9, 0xD9, 0xBA, 0xCF,
                              0xA5, 0x30, 0xE2, 0x63, 0x04, 0x23, 0x14, 0x61,
                              0xB2, 0xEB, 0x05, 0xE2, 0xC3, 0x9B, 0xE9, 0xFC,
                              0xDA, 0x6C, 0x19, 0x07, 0x8C, 0x6A, 0x9D, 0x1B}`
    4 CMAC
        `uint8_t key [] =  {0x70, 0x53, 0x34, 0xe3, 0x0f, 0x53, 0xdd, 0x2f,
                            0x92, 0xd1, 0x90, 0xd2, 0xc1, 0x43, 0x7c, 0x87,
                            0x72, 0xf9, 0x40, 0xc5, 0x5a, 0xa3, 0x5e, 0x56,
                            0x22, 0x14, 0xed, 0x45, 0xbd, 0x45, 0x8f, 0xfe}`

        `uint8_t nonce [] = {0xa5, 0x44, 0x21, 0x8d, 0xad, 0xd3, 0xc1}`
        `uint8_t aadata [] = {0xd3, 0xd5, 0x42, 0x4e, 0x20, 0xfb, 0xec, 0x43,
                              0xae, 0x49, 0x53, 0x53, 0xed, 0x83, 0x02, 0x71,
                              0x51, 0x5a, 0xb1, 0x04, 0xf8, 0x86, 0x0c, 0x98,
                              0x8d, 0x15, 0xb6, 0xd3, 0x6c, 0x03, 0x8e, 0xab}`
        `uint8_t plain [] = { 0x78, 0xc4, 0x6e, 0x32, 0x49, 0xca, 0x28, 0xe1,
                              0xef, 0x05, 0x31, 0xd8, 0x0f, 0xd3, 0x7c, 0x12,
                              0x4d, 0x9a, 0xec, 0xb7, 0xbe, 0x66, 0x68, 0xe3}`
        `uint8_t tagLen [] = 16U;
        `uint8_t cipher [] = {0x33, 0x41, 0x16, 0x8e, 0xb8, 0xc4, 0x84, 0x68,
                              0xc4, 0x14, 0x34, 0x7f, 0xb0, 0x8f, 0x71, 0xd2,
                              0x08, 0x6f, 0x7c, 0x2d, 0x1b, 0xd5, 0x81, 0xce,
                              0x1a, 0xc6, 0x8b, 0xd4, 0x2f, 0x5e, 0xc7, 0xfa,
                              0x7e, 0x06, 0x8c, 0xc0, 0xec, 0xd7, 0x9c, 0x2a}`
